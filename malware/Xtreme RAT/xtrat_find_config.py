# Copyright (c) 2015 FireEye, Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.

import sys
import string
import re
import os
import argparse
from pprint import pprint

def getUnicodeString(buf,pos):
    out = ""
    for i in range(len(buf[pos:])):
        if ord(buf[pos+i]) == 0 and ord(buf[pos+i+1]) == 0:
            out += "\x00"
            break
        out += buf[pos+i]
    
    if out == "":
        return None
    return out
        
def getMutex(buf, exitpos, persistpos):
    #do a backwards comparison from PERSIST and EXIT and continue until there is a mismatch or two null bytes, calculate beginning of the mutex this way
    cnt = 1
    while 1:
        exitc = buf[exitpos - cnt]
        exitc2 = buf[exitpos - cnt - 1]
        persistc = buf[persistpos - cnt]
        persistc2 = buf[persistpos - cnt - 1]
        if exitc != persistc:
            if buf[persistpos - cnt + 1] == "\x00":
                out = buf[persistpos - cnt + 2:persistpos]
            else:
                out = buf[persistpos - cnt + 1:persistpos]
            return out
        if (exitc == "\x00" and exitc2 == "\x00") or (persistc == "\x00" and persistc2 == "\x00"):
            out = buf[persistpos - cnt + 1:persistpos]
            return out
        cnt+=1

def unicodifyre(s):
    return "\\x00".join(s) + "\\x00"
    
def unicodify(s):
    return "\x00".join(s) + "\x00"

def getConfig(f,buf):
    persistre = unicodifyre("PERSIST")
    persist = unicodify("PERSIST")
    exit = unicodify("EXIT")
    persistpattern = r"((?:[^\x00]\x00){4,})" + persistre
    match = re.findall(persistpattern, buf)
    if len(match) > 0:
        configpos = None
        lastfoundoffs = 0
        for m in match:
            print("possible xtrat config located in %s" % f)
            persistpos = string.find(buf[lastfoundoffs:],m)
            persistoffs = string.find(buf[persistpos + lastfoundoffs:],persist)
            persistpos += persistoffs + lastfoundoffs
            lastfoundoffs = persistpos + len(persist)
            exitpos = string.rfind(buf[:persistpos],exit)
            #match last 3 characters of mutex as a sanity check
            if exitpos != -1 and buf[exitpos-6:exitpos] == m[-6:]:
                if persistpos - exitpos == 0x60:
                    print("possible version 1.3.6.x config block found..")
                    mutex = getMutex(buf, exitpos, persistpos)
                    print("mutex: %s" % mutex)
                    configpos = persistpos - len(mutex) - 0x3c8
                    configlen = 0xe10
                    break
                elif persistpos - exitpos == 0x38:
                    print("possible version 3.x config block found..")
                    mutex = getMutex(buf, exitpos, persistpos)
                    print("mutex: %s" % mutex)
                    configpos = persistpos - len(mutex) - 0x33e
                    configlen = 0x7f0
                    break
                elif persistpos - exitpos == 0x7a:
                    print("possible version 2.x config block found..")
                    mutex = getMutex(buf, exitpos, persistpos)
                    print("mutex: %s" % mutex)
                    configpos = persistpos - len(mutex) - 0x109e
                    configlen = 0x1390
                    break
        
        if configpos is not None:
            print("config located at %08X" % configpos)
            with open(os.path.join(f, '.cfg'), 'wb') as fd:
                fd.write(buf[configpos:configpos+configlen])
    else:
        print("could not locate xtrat config")

def getFile(f):
    with open(f, 'rb') as fd:
        return fd.read()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="scans for Xtreme RAT config in memory dumps and writes them to a file of the same name with '.cfg' appended")
    parser.add_argument('i', metavar='Input', help='a path to a memory dump or directory of memory dumps')

    args = parser.parse_args()

    if os.path.isfile(args.i):
        f = args.i
        buf = getFile(f)
        getConfig(f,buf)
    elif os.path.isdir(args.i):
        d = args.i
        for f in os.listdir(d):
            path = os.path.join(d, f)
            if os.path.isfile(path):
                buf = getFile(path)
                getConfig(path,buf)
